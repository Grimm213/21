from tkinter import *           #импортируется модуль графического интерфейса
import sqlite3                  #импортируется модуль по работе с базой данных
import hashlib                  #импортируется модуль для хэширования паролей

class MyFrame(Canvas):           #класс, задающий шаблон для создания моих рамок; класс наследует свойства и методы класса Canvas, который создаёт полотна для рисования в tkinter
    def __init__(self, account_frame):   #конструктор класса, куда передаётся имя главного окна
        Canvas.__init__(self, account_frame, width = 500, height = 550)  #используется конструктор класса Canvas в tkinter, чтобы создать рамку в виде полотна с желаемыми параметрами; вместо Frame выбран Canvas, чтобы у виджетов можно было использовать прозрачный фон
        self.propagate(False)   #запрещается изменять указанные в параметрах размеры рамки
        self.background = PhotoImage(file = 'background.png') #объявляется картинка, которая будет фоном
        self.label = ''         #переменная, где будет храниться заголовок в начале страницы рамки
        self.entry_label = []   #массив, где будут храниться сообщения перед полями ввода в рамке
        self.entry = []         #массив, где будут храниться поля ввода в рамке
        self.button = []        #массив, где будут храниться кнопки в рамке
        
    def show(self, label_text, entry_text, button_text):        #метод, отвечающий за отображение рамки и её содержимого на экране; сюда передаются текст заголовка, массив с текстом сообщений перед полями ввода и массив с текстом на кнопках
        self.pack()                                             #рамка, созданная в конструкторе класса, отображается на экране
        bg = self.create_image(600, 0, anchor='ne', image=self.background) #в рамке отображается картинка-фон
        self.label = Label(self, text = label_text, font = ('Tahoma', 20), fg = 'white', bg = 'royalblue')  #в переменную заголовка записывается виджет сообщения с полученным текстом заголовка
        self.label.pack(pady = 10)                              #заголовок отображается на экране

        for i in range(len(entry_text)):                        #с помощью этого цикла перебираются номера всех элементов в массиве с текстом перед полями ввода 
            self.entry_label += [Label(self, text = entry_text[i], font = ('Tahoma', 20), fg = 'white', bg = 'royalblue')]  #в массив сообщений перед полями ввода добавляется сообщение с соответствующим текстом
            self.entry_label[i].pack(pady = 10)                 #сообщение, добавленное в массив, отражается на экране
            self.entry += [Entry(self, font = ('Tahoma', 20))]  #в массив полей ввода добавляется соответствующее поле ввода
            self.entry[i].pack(pady = 10)                       #поле ввода, добавленное в массив, отображается на экране

        for i in range(len(button_text)):                       #с помощью этого цикла перебираются номера всех элементов в массиве с текстом на кнопках
            self.button += [Button(self, text = button_text[i], font = ('Tahoma', 20), fg = 'white', bg = 'royalblue')]    #в массив кнопок добавляется кнопка с соответствующим текстом на ней
            self.button[i].pack(pady = 10)                      #кнопка, добавленная в массив, отображается на экране


class Authorization:                       #класс авторизации
    def __init__(self, navigator):         #конструктор класса, куда передаётся имя класса главного окна - навигатора
        self.navigator = navigator         #имя класса главного окна делаем свойством класса авторизации
        self.account_frame = self.navigator.account_frame    #имя рамки для полей авторизации в главном окне делаем свойством класса авторизации                    
        self.main_frame = MyFrame(self.account_frame)    #в рамке для полей авторизации создаётся главная рамка как экземпляр класса MyFrame
        self.regist_frame = MyFrame(self.account_frame)  #в рамке для полей авторизации объявляется переменная, где будет хранится рамка регистрации как экземпляр класса MyFrame; здесь сразу создаётся рамка, чтобы задать тип переменной, но это было не обязательно, так как дальше эта рамка каждый раз задаётся заново
        self.enter_frame = MyFrame(self.account_frame)   #в рамке для полей авторизации объявляется переменная, где будет хранится рамка входа как экземпляр класса MyFrame; здесь сразу создаётся рамка, чтобы задать тип переменной, но это было не обязательно, так как дальше эта рамка каждый раз задаётся заново
        self.achivement_frame = MyFrame(self.account_frame)   #в рамке для полей авторизации объявляется переменная, где будет хранится рамка достижений как экземпляр класса MyFrame; здесь сразу создаётся рамка, чтобы задать тип переменной, но это было не обязательно, так как дальше эта рамка каждый раз задаётся заново
        self.main_frame.show('Добро пожаловать!', [], ['Регистрация','Вход в личный кабинет','Скрыть']) #главная рамка отображается на экране с заголовком "Добро пожаловать!" и двумя кнопками "Регистрация" и "Вход"
        self.main_frame.button[0].bind('<Button-1>', lambda event: self.click_regist())       #при нажатии нулевой кнопки с надписью "Регистрация" запускается функция click_regist
        self.main_frame.button[1].bind('<Button-1>', self.click_enter)        #при нажатии нулевой кнопки с надписью "Вход" запускается функция click_enter
        self.main_frame.button[2].bind('<Button-1>', lambda event: self.account_frame.pack_forget())        #при нажатии нулевой кнопки с надписью "Вход" запускается функция click_enter
        self.data = Database()             #создаётся экземпляр класса по работе с базой данных
        self.salt = '5gz'                  #задаётся значение "соли", которое используется при хэшировании, т.е. кодировании паролей; "соль" прибавляется к паролю пользователя, так как она в разных приложениях разная, то хэшированные, закодированные пароли в этих приложениях выглядят по-разному даже, если пользователь везде вводит один и тот же пароль
        self.id = None                     #переменная ключевого кода пользователя, который вошёл в приложение; если никто не вошёл, то это значение не определено
        self.username = None               #переменная имени пользователя, который вошёл в приложение; если никто не вошёл, то это значение пусто
        self.achivement = False            #переменная, которая отслеживает нажата кнопка "Достижения" или нет, если False, то кнопка не нажата и следовательно показывать статистику не надо
        
    def click_regist(self):         #метод класса, запускающийся при нажатии на кнопку "Регистрация" или "Достижения"
        if self.main_frame.button[1]['text'] == 'Выход из личного кабинета': #если на первой кнопке написано "Выход из личного кабинета", то на нулевой кнопке написано "Достижения"
            self.main_frame.pack_forget()  #скрывается главная рамка
            self.achivement = True         #в переменной фиксируется, что кнопка "Достижения" нажата, следовательно, надо отражать статистику
            info = [self.navigator.info_1, self.navigator.info_2, self.navigator.info_3, self.navigator.info_4, self.navigator.info_5, self.navigator.info_6, self.navigator.info_7] #создаётся массив классов информации, чтобы далее по номеру выбранной игры можно было выбрать соответствующий класс информации
            info[self.navigator.choice - 1].history() #в классе информации, соответствующем номеру выбранной игры, запускается метод, отображающий историю операций на экране

        else:
            self.main_frame.pack_forget()  #скрывается главная рамка
            self.regist_frame = MyFrame(self.account_frame) #в главном окне создаётся рамка регистрации как экземпляр класса MyFrame
            self.regist_frame.show('Введите ваши данные!', ['Имя:','Логин:','Пароль:'], ['Зарегистрировать', 'Отмена']) #рамка регистрации отображается на экране с заголовком "Введите ваши данные", полями ввода с надписями "Имя", "Логин", "Пароль", кнопками с текстом "Зарегистрировать" и "Отмена"
            self.regist_frame.button[0].bind('<Button-1>', self.click_regist_ok) #при нажатии нулевой кнопки с надписью "Зарегистрировать" запускается функция click_regist_ok
            self.regist_frame.button[1].bind('<Button-1>', lambda event: self.click_cancel(self.regist_frame)) #при нажатии первой кнопки с надписью "Отмена" запускается функция click_cancel, куда передаётся имя рамки регистрации, чтоб её можно было скрыть
    
    def click_regist_ok(self, event):                       #метод класса, запускающийся при нажатии на кнопку "Зарегистрировать"
        name = self.regist_frame.entry[0].get().strip()     #локальная переменная, куда записывается значение имени пользователя, получаемое из нулевого поля ввода рамки регистрации с удалением крайних пробелов, если они есть
        login = self.regist_frame.entry[1].get().strip()    #локальная переменная, куда записывается значение логина пользователя, получаемое из первого поля ввода рамки регистрации с удалением крайних пробелов, если они есть
        password = self.regist_frame.entry[2].get().strip() #локальная переменная, куда записывается значение пароля пользователя, получаемое из второго поля ввода рамки регистрации с удалением крайних пробелов, если они есть

        if name == '' or login == '' or password == '':     #если какое-либо полученное значение пусто или содержало пробелы, которые были убраны при считывании этого значения, то ничего не выполняется, а лишь выводится сообщение ниже
            self.regist_frame.label.config(text = 'Все поля должны быть заполнены!')       #меняется текст заголовка рамки регистрации
        elif self.data.find('SELECT id, name FROM Users WHERE login = ?', (login,)) != []: #иначе, т.е. если все поля заполнены, то в экземпляре класса по работе с базой данных запускается метод поиска записей в базе данных с введённым логином, если результатом такого поиска является не пустой массив, то
            self.regist_frame.label.config(text = 'Такой логин уже существует!')           #меняется текст заголовка рамки регистрации; он сообщает, что введённый логин уже существует и надо ввести другой логин
        else:                                               #иначе, т.е. если все поля заполнены и логин уникальный, то
            self.regist_frame.pack_forget()                 #рамка регистрации скрывается
            password_salt = password + self.salt            #к паролю пользователя прибавляется значение "соли" этого приложения
            hashed_password = hashlib.md5(password_salt.encode('utf-8')).hexdigest()       #пароль с "солью" хэшируется, т.е. кодируется с помощью метода md5 модуля hashlib 
            self.data.insert_user(name, login, hashed_password)                            #в экземпляре класса по работе с базой данных запускается метод добавления новой записи в базу данных с полученным именем, логином и хэшированным паролем пользователя
            print(self.data.find('SELECT * FROM Users'))                                   #в экземпляре класса по работе с базой данных запускается метод поиска всех записей в базе данных, результат, т.е. массив со значениями всех записей, выводится в консоль для проверки правильности работы приложения
            self.main_frame.label.config(text = 'Регистрация успешно пройдена!')           #в главной рамке меняется текст заголовка, он сообщает об успешной регистрации
            self.main_frame.pack()                                                         #главная рамка отображается на экране

    def click_enter(self, event):                                    #метод класса, запускающийся при нажатии на кнопку с надписью "Вход" или "Выход", эта кнопка может иметь разные надписи 
        if self.main_frame.button[1]['text'] == 'Выход из личного кабинета':             #если на первой кнопке главной рамки написано "Выход", а это происходит, если какой-то пользователь вошёл в приложение, то при нажатии на неё
            self.main_frame.label.config(text ='Добро пожаловать!')  #в главной рамке меняется текст заголовка на общее приветствие
            self.id = None                                           #переменная ключевого кода пользователя, вошедшего в приложение, обнуляется
            self.username = None                                     #переменная имени пользователя, вошедшего в приложение, тоже обнуляется
            self.navigator.user_id = self.id                         #переменная ключевого кода пользователя в навигаторе обновляется
            self.navigator.user_name = self.username                 #переменная имени пользователя в навигаторе обновляется
            self.main_frame.button[0].config(text ='Регистрация')           #надпись на нулевой кнопке главной рамки меняется с "Достижения" на "Регистрация"; надпись меняется, чтобы не создавать новой кнопки
            self.main_frame.button[1].config(text ='Вход в личный кабинет') #надпись на первой кнопке главной рамки меняется с "Выход" на "Вход"; надпись меняется, чтобы не создавать новой кнопки
        else:                                                        #иначе, т.е. если на первой кнопке главной рамки написано "Вход", то
            self.main_frame.pack_forget()                            #главная рамка скрывается
            self.enter_frame = MyFrame(self.account_frame)                         #в главном окне создаётся рамка входа как экземпляр класса MyFrame
            self.enter_frame.show('Введите логин и пароль!', ['Логин:','Пароль:'], ['Войти', 'Отмена'])     #рамка входа отображается на экране с заголовком "Введите логин и пароль!", полями ввода с надписями "Логин", "Пароль", кнопками с текстом "Войти" и "Отмена"
            self.enter_frame.button[0].bind('<Button-1>', self.click_enter_ok)                              #при нажатии нулевой кнопки с надписью "Войти" запускается функция click_enter_ok
            self.enter_frame.button[1].bind('<Button-1>', lambda event: self.click_cancel(self.enter_frame))#при нажатии первой кнопки с надписью "Отмена" запускается функция click_cancel, куда передаётся имя рамки входа, чтоб её можно было скрыть

    def click_enter_ok(self, event):                                 #метод класса, запускающийся при нажатии на кнопку "Войти"
        login = self.enter_frame.entry[0].get().strip()              #локальная переменная, куда записывается значение логина пользователя, получаемое из нулевого поля ввода рамки входа с удалением крайних пробелов, если они есть
        password = self.enter_frame.entry[1].get().strip()           #локальная переменная, куда записывается значение пароля пользователя, получаемое из первого поля ввода рамки входа с удалением крайних пробелов, если они есть
        password_salt = password + self.salt                         #к паролю пользователя прибавляется значение "соли" этого приложения
        hashed_password = hashlib.md5(password_salt.encode('utf-8')).hexdigest()    #пароль с "солью" хэшируется, т.е. кодируется с помощью метода md5 модуля hashlib 
        result = self.data.find('SELECT id, name FROM Users WHERE login = ? AND password = ?', (login, hashed_password)) #в экземпляре класса по работе с базой данных запускается метод поиска записей в базе данных с введённым логином  и паролем; результатом такого поиска является массив с ключевым кодом и именем пользователя, или пустой массив, если совпадений не найдено
        if result == []:                     #если результатом поиска записи с заданным логином и паролем является пустой массив, т.е. такой записи не найдено, то      
            self.enter_frame.label.config(text ='Неверный ввод логина или пароля!') #в заголовке рамки входа меняется текст
        else:                                #иначе, т.е. если соответствующая запись найдена, то
            self.enter_frame.pack_forget()   #рамка входа скрывается
            self.id = result[0][0]           #в переменную ключевого поля пользователя, вошедшего в приложение, записывается нулевое значение из нулевого кортежа массива результата; значения каждой отдельной записи записываются в массив в виде кортежа; так как логины в базе данных не повторяются, то найденная запись может быть только одна, поэтому в массиве есть только нулевой кортеж, в котором на нулевом месте записан ключевой код, а на первом месте имя пользователя
            self.username = result[0][1]     #в переменную имени пользователя, вошедшего в приложение, записывается первое значение из нулевого кортежа массива результата; значения каждой отдельной записи записываются в массив в виде кортежа; так как логины в базе данных не повторяются, то найденная запись может быть только одна, поэтому в массиве есть только нулевой кортеж, в котором на нулевом месте записан ключевой код, а на первом месте имя пользователя
            self.navigator.user_id = self.id #переменная ключевого кода пользователя в навигаторе обновляется
            self.navigator.user_name = self.username #переменная имени пользователя в навигаторе обновляется
            self.main_frame.label.config(text = 'Добро пожаловать, ' + self.username + '!') #в заголовке главной рамки меняется текст заголовка на приветствие пользователя, вошедшего в приложение
            self.main_frame.button[0].config(text ='Достижения')                 #надпись на нулевой кнопке главной рамки меняется с "Регистрация" на "Достижения"; надпись меняется, чтобы не создавать новой кнопки
            self.main_frame.button[1].config(text ='Выход из личного кабинета')          #надпись на первой кнопке главной рамки меняется с "Вход" на "Выход"; надпись меняется, чтобы не создавать новой кнопки
            self.main_frame.pack()           #главная рамка отражается на экране

    def click_cancel(self, current_frame):   #метод класса, запускающийся при нажатии на кнопку "Отмена", куда передаётся имя текущей открытой рамки, т.е. рамки регистрации или рамки входа
        current_frame.pack_forget()          #текущая открытая рамка скрывается
        if self.id == None:
            self.main_frame.label.config(text ='Добро пожаловать!') #в главной рамке текст заголовка меняется на общее приветствие
        else:
            self.main_frame.label.config(text = 'Добро пожаловать, ' + self.username + '!') #в заголовке главной рамки меняется текст заголовка на приветствие пользователя, вошедшего в приложение
        self.achivement = False              #в переменной фиксируется то, что кнопка "Достижения" теперь не нажата, и статистику выводить не надо
        self.main_frame.pack()               #главная рамка отображается на экране

        
class Database:                                #класс по работе с базой данных
    def __init__(self):                        #конструктор класса
        self.connection = ''                   #объявляется переменная, где будет храниться соединение с базой данных
        self.cursor = ''                       #объявляется переменная, гда будет храниться объект-курсор, который будет пробегать по базе данных при выполнении соответствующих запросов или команд
        self.create_table_Users()              #запускается метод класса по созданию таблицы пользователей, если она ещё не создана, если она создана, то ничего не произойдёт
        result = self.find('SELECT * FROM Users') #записывается результат запуска метода класса по поиску записей в базе данных, в данном запросе ищутся все записи таблицы пользователей
        self.number = len(result)              #в переменную общего количества записей в таблице записывается число элементов массива - результата предыдущего запроса; элементами массива являются кортежи со значениями соответствующих записей
        if len(result) == 0:                   #если массив - результат запроса пустой, т.е. в таблице нет никаких записей, то
            self.last_key = 0                  #последнее значение ключевого кода берётся равным нулю
        else:                                  #иначе, т.е. если записи в таблице есть, то
            self.last_key = result[-1][0]      #последнее значение ключевого кода берётся в последнем кортеже массива - результата равным нулевому элементу, на этом месте в каждом кортеже хранится ключевой код соответствующей записи

    def change(self, query, values = ()):      #метод класса, отвечающий за внесение изменений в базу данных в соответствии с передаваемым сюда запросом в виде строки и значениями к этому запросу в виде кортежа; если никакие значения не переданы, то по умолчанию используется пустой кортеж значений
        self.connection = sqlite3.connect('my_database.db') #создаётся соединение с файлом базы данных
        self.cursor = self.connection.cursor() #создаётся объект - курсор, который будет пробегать по базе данных при выполнении соответствующих запросов
        try:                                   #модуль обработки исключений на случай, если запрос на изменения базы данных будет некорректным
            self.cursor.execute(query, values) #объекту - курсору даётся команда выполнить переданный запрос или команду с соответствующими значениями; если запрос с ошибками, то изменения выполнены не будут, а программа перейдёт в блок except
            self.connection.commit()           #выполненные изменения подтверждаются; если этого не сделать, то эти изменения не будут внесены в базу данных; программы переходит в блок finally
        except:                                #блок, куда переходит выполнение программы, если запрос с ошибкой
            print('Неверный ввод!')            #в консоли пишем сообщение о том, что была попытка неправильного запроса к базе данных, чтобы принять это к сведению и разобраться с этим, если надо
        finally:                               #блок, куда переходит выполнение программы в любом случае независимо от того, была ошибка или её не было
            self.connection.close()            #соединение с файлом базы данных закрывается

    def create_table_Users(self):              #метод класса для создания таблицы пользователей
        self.change('''
        CREATE TABLE IF NOT EXISTS Users (
        id INTEGER PRIMARY KEY,
        name TEXT NOT NULL,
        login TEXT NOT NULL,
        password TEXT NOT NULL)
        ''')                                   #вызывается метод класса, изменяющий базу данных, куда передаётся запрос на создание таблицы пользователей, если она не была создана до этого, с полями, где будет храниться ключевой код, имя, логин и пароль пользователя

    def insert_user(self, name, login, password): #метод класса для добавления записи для нового пользователя, куда передаются соответствующие данные этого пользователя: имя, логин и пароль
        self.number += 1                       #значение переменной общего количества пользователей в базе данных увеличивается на 1
        self.last_key += 1                     #последнее значение ключевого кода пользователя увеличивается на 1, это значение присвоится новому пользователю
        self.change("INSERT INTO Users VALUES(?, ?, ?, ?)", (self.last_key, name, login, password)) #вызывается метод класса, изменяющий базу данных, куда передаётся запрос на добавление новой записи в таблицу пользователей и соответствующие значения ключевого кода, имени, логина и пароля нового пользователя
        
    def find(self, query, values = ()):        #метод класса, отвечающий за поиск данных в базе в соответствии с передаваемым сюда запросом в виде строки и значениями к этому запросу в виде кортежа; если никакие значения не переданы, то по умолчанию используется пустой кортеж значений
        self.connection = sqlite3.connect('my_database.db') #создаётся соединение с файлом базы данных
        self.cursor = self.connection.cursor() #создаётся объект - курсор, который будет пробегать по базе данных при выполнении соответствующих запросов
        self.cursor.execute(query, values)     #объекту - курсору даётся команда выполнить переданный запрос или команду с соответствующими значениями
        result = self.cursor.fetchall()        #в переменную результата записывается массив всех найденных в соответствии с запросом записей
        self.connection.close()                #соединение с файлом базы данных закрывается
        return result                          #результат, т.е. массив со всеми найденными записями, передаётся в то место программы, откуда этот метод был вызван

if __name__ == '__main__':  #если текущий файл является стартовым, то выполняются все команды ниже, иначе ничего не происходит

    class Navigator:              #создаётся класс, имитирующий класс главного окна - навигатора
        def __init__(self):       #конструктор класса
            self.user_id = None   #создаётся переменная, хранящая ключевой код пользователя, осуществившего вход
            self.user_name = None #создаётся переменная, хранящая имя пользователя, осуществившего вход
            self.account_frame = Frame(root) #в главном окне - навигаторе создаётся рамка для полей авторизации
            self.account_frame.pack()        #рамка для полей авторизации отображается на экране
        
    root = Tk()             #создаётся первоначальное окно
    navigator = Navigator() #создаётся класс окна - навигатора
    Authorization(navigator)     #создаётся экземпляр класса, отвечающий за авторизацию пользователя, куда передаётся имя окна - навигатора
    root.mainloop()         #первоначальное окно активируется, т.е. запускается цикл, который отслеживает какие-либо изменения элементов окна
